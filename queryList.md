# TinkerPop 3.x Gremlin 3.6 Core Steps Reference
=
| Step | Category | Aliases / Variations | Input → Output | Example (Gremlin-JS) | Notes / Pitfalls |
| --- | --- | --- | --- | --- | --- |
| inject(objects...) | Start / Inject | –   | _none_ → object | g.inject(1,2,3) | Injects arbitrary objects into traversal[\[63\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,vadas). Often used to start traversals not tied to graph elements. The inserted objects have no graph context. |
| otherV() | Graph Navigation (map) | –   | Edge → Vertex | g.V(1).outE('knows').otherV() | From an edge, returns “the other” vertex (i.e., if the traverser came from one vertex to this edge, otherV() gives the opposite vertex)[\[8\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,vertices). If used without a prior path context, it behaves like bothV() but filtered to exclude a known vertex if one is in the traverser’s path. |
| identity() | Utility (map) | –   | X → X (same as input) | g.V().identity() | No-op step[\[73\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Identity%20Step) – returns the traverser unchanged. Useful as an explicit pass-through or as a default “else” in branching (e.g., choose(..., identity()))[\[74\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%3D%3D,lop). Also serves as the identity element in Gremlin’s function composition (monoid)[\[75\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,by%20the%20functional%20programming%20community). |
| constant(value) | Utility (map) | –   | X → constant | g.V().constant(0) | Emits the given constant value for each incoming traverser. For example, can tag each result with a fixed marker. If used at start (with no input), it will output the constant once. |

**Figure: Vertex Navigation** – The out(), in(), and related steps allow traversal of the graph’s connectivity. For example, starting at the **Marko** vertex, out('knows') would yield the vertices **Vadas** and **Josh** (Marko’s “knows” connections). An outE('created') from **Marko** yields the **created** edges to projects **Lop** and **Ripple**, and an inV() on those edges gives the project vertices. The diagram below illustrates moving from a vertex through edges to connected vertices via these steps:

_Illustration of core graph navigation steps. Starting from a vertex (e.g., Marko), out('knows') finds outgoing adjacent vertices along "knows" edges, while in('knows') would find incoming connections. both() covers both directions. Similarly, outE('created') retrieves outgoing "created" edges from Marko, and then inV() brings you to the vertices on the incoming side of those edges (the created software projects). This demonstrates how Gremlin’s navigation steps allow traversing the graph structure._[\[68\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,g.V%284%29.bothE%28%27knows%27%2C%27created%27%2C%27blah)[\[76\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,v%5B5)

### Filtering Steps

Filter steps allow or deny traversers passage based on specified criteria. They do not change the objects carried by the traverser (except that failing traversers are terminated).

| Step | Category (Type) | Aliases / Variations | Input → Output | Example (Gremlin-JS) | Notes / Common Pitfalls |
| --- | --- | --- | --- | --- | --- |
| hasNot(key) | Property Filter (filter) | _(deprecated in 3.x)_ | Element → Element | _Use not(has(key))_ | In TinkerPop 3.x, hasNot is removed; use not(has(key)) to filter elements lacking a property. |
| where(predicate) | General Filter (filter) | –   | Object → Object | g.V().where(\__.outE().count().is(0)) | A versatile filter with two modes: **local** (default) or **global**. Local mode treats the current object for the predicate, e.g., where(P.gt(10)) on a number. Global mode is triggered when the traversal uses labels or path (e.g., where(\__.out('knows')) or where(eq('foo')) refers to the object with label “foo” in the traverser’s path)[\[78\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Where%20Step). **Pitfall:** Remember to use \__. for anonymous traversals inside where. Also, where(eq('x')) requires that an as('x') label exists earlier in the traversal; otherwise it always filters out. |
| and(...traversals...) | Logical Filter (filter) | –   | Object → Object | g.V().and(\__.out('knows'), \__.out('created')) | Logical AND: the traverser passes only if **all** provided sub-traversals yield at least one result[\[17\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L2744%20The%20%60and%28%29%60,semantics). Each traversal is run starting from the current object. In the example, a vertex passes if it has both an outgoing “knows” edge _and_ an outgoing “created” edge. |
| or(...traversals...) | Logical Filter (filter) | –   | Object → Object | g.V().or(\__.has('flag',true), \__.out('special')) | Logical OR: passes if **any** sub-traversal yields a result. For performance, Gremlin will stop evaluating further OR traversals as soon as one succeeds (short-circuit behavior). |
| not(traversal) | Logical Filter (filter) | –   | Object → Object | g.E().not(\__.properties('archived')) | Negation filter: allows a traverser only if the provided traversal yields nothing for it. E.g., this filters edges that **do not** have an “archived” property. Internally, it’s essentially or(traversal).not() in logic. |
| is(valueOrPred) | Value Filter (filter) | –   | Object → Object | g.V().values('age').is(P.inside(20,30)) | Filters the current object by direct comparison or a predicate condition. If given a value (like is(5)), only traversers with exactly that value pass. With a P predicate (e.g. P.inside(20,30)), uses that condition[\[11\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%60filter%28Traversal). **Pitfall:** Ensure the input objects are of a type that can be compared to the provided value; otherwise the filter might always fail. |
| coin(probability) | Random Filter (filter) | –   | Object → Object | g.V().coin(0.5) | Randomly allows traversers to proceed with the given probability (0.0 to 1.0). E.g., 0.5 ~ 50% chance each. This is independent for each traverser (like flipping a biased coin for each)[\[18\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=To%20randomly%20filter%20out%20a,coin%20toss). Useful for sampling or random walks. |
| range(low, high) | Range Filter (filter) | –   | Object → Object | g.V().values('name').range(0, 5) | Allows only a slice of the traversers through (by their **order in the stream**). Analogous to an index range: low is inclusive, high is exclusive (stop before index). Example returns only the first 5 names. If high is beyond the stream length, all up to end pass. **Pitfall:** Order in Gremlin is not guaranteed unless explicitly sorted; range is typically applied after an order() if a specific ordering is needed[\[79\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Warning). |
| limit(n) | Range Filter (filter) | –   | Object → Object | g.V().limit(100) | Shorthand for range(0, n). Allows only the first _n_ traversers to pass and cuts off the rest. |
| skip(n) | Range Filter (filter) | –   | Object → Object | g.V().skip(1) | Skips the first _n_ traversers and allows the rest. Essentially range(n, ∞). E.g., skip(1) drops the first result and returns from the second onward. |
| tail(n) | Range Filter (filter) | –   | Object → Object | g.V().tail(1) | Allows only the last _n_ traversers in the stream. If n=1, only the final traverser (in a stream of unknown length, Gremlin will buffer if needed). Often used to get the most recently added or highest-index element when combined with an order or inherent ordering. |
| dedup(scope, by…) | Deduplication (filter) | –   | Object → Object | g.V().values('lang').dedup() | Removes duplicate traverser objects (keeping only the first occurrence)[\[80\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L3583%20With%20%60dedup%28%29%60,to%201%20before%20being%20emitted). By default, considers the object’s value itself; an optional by modulation can specify a projection for comparison (e.g., .dedup().by('name') to deduplicate vertices by name). **Bulk note:** If a traverser has bulk >1, dedup will reduce its bulk to 1 (it only needs one instance to represent the group)[\[81\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=With%20%60dedup%28%29%60,to%201%20before%20being%20emitted). |
| until(predicate) | (Loop modulator) | –   | –   | _Used with repeat_ | Not an independent step – used inside repeat() to specify the loop break condition. For completeness: it filters loop continuation. E.g., repeat(...).until(loops().is(3)). (See **Branching/Looping**.) |
| emit(predicate) | (Loop modulator) | –   | –   | _Used with repeat_ | Not an independent step – used inside repeat() to emit interim results even if loop will continue. E.g., emit(breakCond) will output traversers that meet the condition during looping. If used without a predicate (emit()), it outputs at every iteration (including 0th). (See **Branching/Looping**.) |
| simplePath() | Path Filter (filter) | –   | Element → Element | g.V().repeat(out()).until(has('name','joe')).simplePath() | Allows only traversers whose path from start to current point contains no repeated vertices[\[82\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,modulation). This prevents cycles and revisiting the same vertex. Often used in recursive traversals to avoid infinite loops. **Note:** It considers the _entire_ path history; if used at start of traversal it has no effect until a path forms. |
| cyclicPath() | Path Filter (filter) | –   | Element → Element | g.V().until(has('cycle',true)).repeat(out()).cyclicPath() | Opposite of simplePath(): it filters **out** traversers whose path is _not_ cyclic. In other words, it **allows only** those traversers that have encountered a vertex twice (i.e., detected a cycle in the path)[\[14\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L3525%20%60cyclic%28%29%60,behavior%20is%20desired%2C%20see%20simplePath). Rarely used unless specifically looking for loops in the graph. |
| where(startKey…​) | Path/Label Filter (filter) | –   | Object → Object | g.V('alice').as('a').out('knows').where(neq('a')) | A variant of where() that uses label references directly. E.g., where(neq('a')) filters the current object against the object at label a in the path[\[83\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,g.V%281%29.out%28%27created%27%29.in%28%27created%27%29.where%28out%28%27created%27%29.count%28%29.is). (This is effectively a short form for where(\__.is(P.neq(select('a')))).) Commonly used to enforce that two path variables are different. |
| not(...) | (See above) | –   | –   | –   | _(See not(traversal) above. Listed once.)_ |
| and(...) | (See above) | –   | –   | –   | _(See and() above.)_ |
| or(...) | (See above) | –   | –   | –   | _(See or() above.)_ |

### Branching & Looping Steps

These steps direct traversers down different paths or into loops based on conditions. They are crucial for implementing conditional logic and repeating patterns within Gremlin traversals.

| Step | Category (Type) | Aliases / Related | Input → Output | Example (Gremlin-JS) | Notes / Common Pitfalls |
| --- | --- | --- | --- | --- | --- |
| choose(cond, trueTrav, falseTrav) | Branch (branch) | Variations: choose(conditionTraversal) .option(val1,trav1).option(val2,trav2)... | Object → Object (varies) | g.V().hasLabel('person').choose(\__.values('age').is(P.lte(30)), \__.in_('knows'), \__.out('knows')) | If-then-else logic[\[20\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Choose%20Step). The first form uses a boolean condition traversal; if it yields anything (true), the traverser goes into trueTrav, otherwise into falseTrav[\[21\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1,based%20option%20selection). The second form (with .option) uses a traversal that produces a value (like a switch key) and routes traversers to the matching option traversal[\[24\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=g,values%28%27name%27%29%20%2F%2F2). If a traverser’s key doesn’t match any option and no default (option(Pick.none, traversa)) is provided, it is dropped. **Pitfall:** Ensure that the true/false traversals or options cover all cases you want; otherwise traversers can vanish if no branch is taken. Also, choose is a single step – don't confuse it with multiple if-else: a chain of choose steps can be used for multiple conditions. |
| option(key, traversal) | Branch (branch) | –   | (used with choose) | (used within choose) | Defines a branch option for choose(val) usage[\[84\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,josh). Not used standalone; only as part of the fluent API of a choose(traversal) step. In Gremlin-JS, you’d chain .option(value, \__.traversal) after a choose(valueTraversal). |
| coalesce(travA, travB, ...) | Branch (flatMap) | –   | Object → Object | g.V(1).coalesce(\__.out('friends'), \__.out('coworkers'), \__.constant('loner')) | Tries each traversal in order and returns the result of the _first_ one that produces any output[\[25\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Coalesce%20Step). In the example, for a given person vertex, if they have any “friends” out-edges, those friend vertices are returned; if not, it tries “coworkers”; if that also yields nothing, it falls back to a constant “loner”. This is effectively an ordered OR-resolution. **Pitfall:** All traversals after the first successful one are skipped for that traverser. If multiple traversals can yield results and you intended to get results from _all_ of them, use union instead. |
| union(travA, travB, ...) | Branch (flatMap) | –   | Object → Object | g.V(1).union(\__.out('knows'), \__.out('created')) | Runs all provided traversals in parallel on the input and **combines all the results**. Unlike coalesce, it does not short-circuit – every branch is evaluated and all outputs are returned (interwoven in the traversal stream)[\[85\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Gremlin%20with%20). The example gets both the people Marko knows and the projects Marko created. **Note:** Result order is not guaranteed relative to branches; if order matters, follow with an explicit sort. Also, be mindful of performance if branches are expensive – they all execute. |
| branch(fun) | Branch (flatMap) | –   | Object → Object | g.V().branch(v -> v.label()) .option('person', \__.out('knows')) .option('software', \__.out('created')) | Multi-branch using a user-supplied function on the object to determine the route. In Gremlin-JS, the function would typically be expressed as a lambda (which might not be supported remotely) or using choose/union alternatives. This step is more common in Gremlin-Java. It yields whatever the chosen traversal yields. **Pitfall:** Branch with function is less portable across languages/servers due to lambdas. Prefer choose(...).option(...).option(...) for multi-way branching without lambdas when possible. |
| repeat(traversal) | Loop (branch) | –   | Object → Object | g.V(1).repeat(\__.out()).times(3) | Repeats the specified traversal multiple times (forming a loop)[\[28\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Another%20example%20is%20the%20repeat%28%29,a%20loop). By itself, repeat will loop until traversal exhaustion (potentially forever). Use .times(n) for a fixed number of iterations, or .until(condition) for a conditional break. You can also add .emit(condition) to output interim results. The input serves as the start for the first iteration, and subsequent iterations feed on the previous outputs. **Pitfall:** An unconstrained repeat without until or times can cause infinite loops if the graph has cycles or if the repeated traversal can always continue. Always include a stopping condition or use cycles filters (simplePath) inside the loop to prevent infinite traversal. Also, when using repeat, remember that the traverser’s path accumulates each iteration unless you filter it. |
| until(predicate) | Loop modulator | –   | –   | ...repeat(\__.out()).until(\__.has('flag','end')) | Used inside a repeat to specify the loop break condition (exit when this is true)[\[30\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin%3E%20g.V%28%29.emit%28__.has%28,lop). The predicate is evaluated after each iteration; when it returns true, the loop stops (not emitting that iteration’s result unless an emit says otherwise). (See above in Filtering Steps for more.) |
| emit(predicate) | Loop modulator | –   | –   | ...repeat(\__.out()).emit(\__.has('level',3)).until(... ) | Used with repeat to emit traversers during looping[\[29\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=console%20). If a predicate is supplied, it emits when predicate is true; if no predicate, emits at every iteration. Emitted results still continue through the loop if the until hasn’t triggered. Common use: generate all intermediate nodes in a breadth-first search, etc. |
| loops() | Loop counter (map) | –   | Object → Number | repeat(\__.out()).until(loops().is(5)) | Returns the number of times the traverser has gone through the loop so far[\[31\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Loops%20Step). Only valid inside a repeat traversal. Often used in until/emit conditions (e.g., stop after N loops: until(loops().is(N))). |
| optional(traversal) | Branch (flatMap) | –   | Object → Object | g.V(2).optional(\__.out('knows').has('name','Marko')) | An optional branch that tries the traversal and returns its result if it finds any, otherwise keeps the original element[\[27\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60optional%28%29%60,identity). It’s essentially coalesce(traversal, identity()). In the example, for vertex 2, if it has an outgoing “knows” edge to someone named Marko, that Marko vertex will be the result; if not, vertex 2 itself remains. **Pitfall:** If the optional traversal yields multiple results, all of those replace the original (which is dropped). If it yields none, the original continues. This differs from filtering: nothing is dropped unless the _optional_ traversal explicitly filters inside itself. |
| match(...patterns...) | Pattern (map&lt;sup&gt;\*&lt;/sup&gt;) | –   | Object → Map (of bound vars) or as specified | g.V().match(\__.as('a').out('created').as('b'), \__.as('b').has('name','lop'), \__.as('b').in('created').as('c'), \__.as('c').has('age',29)).select('a','c').by('name') | Evaluates multiple **pattern traversals** simultaneously, binding variables (with as('x')) that must be consistent across patterns[\[33\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,a%3Apeter%2Cc%3Amarko). The output of match() is by default a Map of the bound variables (e.g. {'a': v1, 'b': v2, 'c': v3} for each successful combination). Often you’ll follow with select() to project the ones you need (as in example)[\[33\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,a%3Apeter%2Cc%3Amarko)[\[86\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,by%28%27name). **Pitfalls:** All patterns in match() are considered conjunctively – every pattern must succeed. If any pattern fails for a traverser, that entire traverser fails the match. Ordering of patterns can affect performance but not correctness; TinkerPop’s engine will reorder patterns for an optimal join (especially on OLAP)[\[35\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=traverser%20%28i,Furthermore%2C%20some%20queries%20are). Each pattern should have at least one as('X') that appears in another pattern (to link them); if you have completely independent patterns, the result can be a Cartesian product or may never succeed. Also, using match inside a repeat or vice versa can be complex – be mindful of path scoping. |
| **Cross-Reference:** |     |     |     |     | Many branch steps have related uses: For example, optional() is equivalent to a choose with identity as the false branch, and can be mimicked by coalesce. coalesce(\[...\]) with an unfold() of a collection is a common pattern for “if empty then do X”. Also see **Filtering** for not(...), and, or which provide branch-like logic at the predicate level. |

_Example of a branching step: The choose() step (if-then-else). Here we route person vertices based on age. Persons age ≤ 30 follow the in('knows') branch (traversing incoming “knows” edges), while others follow the out('knows') branch. The diagram shows Marko (age 29) taking the "true" branch (inward connections) and others like older persons taking the "false" branch (outward connections). The choose() step thus conditionally directs traversers, analogous to an if/else in imperative code._[\[87\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20choose%20step)[\[21\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1,based%20option%20selection)

### Graph Mutation Steps

These steps create or modify elements in the graph. They are **sideEffect** steps (since they change the graph’s state) and typically also yield the element so that the traversal can continue (making them also behave like map steps, outputting the new or changed element).

| Step | Category (Type) | Aliases / Variations | Input → Output | Example (Gremlin-JS) | Notes / Common Pitfalls |
| --- | --- | --- | --- | --- | --- |
| mergeV(map) | Graph Mutation (flatMap & sideEffect) | –   | Object/None → Vertex | g.mergeV({label: 'airport', code: 'SFO'}) | Merges a vertex: finds a vertex matching the provided map of properties if one exists, otherwise creates a new one[\[43\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=One%20of%20the%20most%20compelling,your%20code%20more%20readable%20and)[\[44\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=As%20an%20example%20of%20,Vertex). The map typically contains identifying fields (and optionally T.id or T.label). E.g., the example will ensure there is an ‘airport’ vertex with code “SFO” (creating it if needed). If merging by id and that id exists with different properties, those properties might be updated or left as-is depending on the mergeV implementation (in 3.6, you can also specify onCreate/onMatch traversals for fine control, omitted here for brevity). **Pitfall:** If the criteria in the map are not unique and multiple vertices match, the behavior may depend on the implementation (usually it picks one arbitrarily – potentially non-deterministic). Also, not all graphs allow arbitrary IDs; providing T.id might only work if the graph supports user-supplied IDs. |
| mergeE(map) | Graph Mutation (flatMap & sideEffect) | –   | Object/None → Edge | g.V().has('code','ATL').as('a').V().has('code','SFO').as('b').mergeE({label:'route', (to): 'b', dist: 500}).from('a') | Merges an edge according to a provided map of properties (similar idea to mergeV). The map must include at least a label and identifiers for the incident vertices. In the example, we merge a "route" edge from the vertex with code ATL to the one with code SFO, with distance property. The (to): 'b' syntax represents using the vertex at label 'b' as the target (in JavaScript GLV, use to('b') outside the map, as shown, since embedding it in the map might not directly work; the concept here is that mergeE needs to know both endpoints). **Note:** mergeE in 3.6.x is advanced; it’s often easier to use by first anchoring the traversal on a source vertex and then calling mergeE with a map that includes (T.id) or other unique key for the edge and a (to) key for the target vertex ID or label[\[88\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=gremlin,id%3D215%2C%20label%3Dairport%7D%2C%20dist%3D813). **Pitfall:** As with mergeV, multiple matches or user-defined IDs need careful handling. If the graph doesn’t support upsert on edges in one step, mergeE might not be atomic (it could do a behind-the-scenes lookup then add). |
| property(Cardinality, key, value) | Graph Mutation (sideEffect) | –   | Element → Element | g.V(100).property(single, 'age', 42) | (Not available in GLV directly, usually used in Gremlin-Java/Groovy) Sets a property with an explicit cardinality (single or list/set). In Gremlin-JS, cardinality is not typically exposed; use graph schema defaults. |
| addV() / addE() (no args) | Graph Mutation (sideEffect) | –   | –   | g.addV() (no label) | These overloads create a vertex with default or no label (which typically means some graph-defined default) or an edge with no label (not allowed – edges require a label). Generally, always supply a label for clarity. |
| drop() | Removal (filter & sideEffect) | –   | Element → **∅** | g.E().has('temp',true).drop() | (See **Filtering** above.) Removes elements/properties from the graph[\[19\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60drop%28%29%60,traversal%20yields%20no%20outgoing%20objects). No output is produced. **Pitfall:** If you drop vertices mid-traversal and then attempt to use them later in the traversal (via a stored reference or side-effect), you’ll likely get errors or stale references. Also, dropping a vertex will automatically drop its adjacent edges – this can be expensive if the vertex has many edges. Consider using .iterate() to perform mass deletion outside of a result-producing traversal if appropriate (e.g., g.V().has(...).drop().iterate()). |

### Side-Effect & Aggregation Steps

These steps collect information, maintain state, or cause some side-effect during traversal execution. Many are barrier steps that only emit output after processing all inputs.

| Step | Category (Type) | Aliases / Variations | Input → Output | Example (Gremlin-JS) | Notes / Common Pitfalls |
| --- | --- | --- | --- | --- | --- |
| sideEffect(traversal) | Side Effect (sideEffect) | –   | Object → Object (same) | g.V().hasLabel('person').sideEffect(\__.properties('name').count().store('nameCount')) | Executes the traversal for its side effect and passes the input object unchanged[\[48\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=3.%20,S%20%E2%86%92%20E%20%E2%8A%86%20S). In this example, for each person vertex, it counts name properties (should be 1 per vertex) and stores the count in a side-effect collection 'nameCount', while still outputting the original vertex. Use cases: logging, aggregating metrics, triggering some action. **Pitfall:** The sideEffect traversal is executed **for each traverser** independently. If you have a large stream, this could be costly. Also, if you modify the graph in the sideEffect traversal, be mindful of transaction consistency (the main traversal and side traversal share context). |
| aggregate('key') | Side Effect (sideEffect, barrier with global scope) | –   | Object → Object (same) | g.V().aggregate('x').by('name') | Globally accumulates objects (or a projection) into a collection stored under a side-effect key[\[89\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20aggregate%20step). By default, it uses a **global** scope: it will not emit the next step until all incoming traversers have been aggregated (eager barrier)[\[90\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60aggregate%28%29%60,An%20example%20is%20provided%20below). In the example, all vertex names are aggregated. The step then continues passing each vertex forward (so vertices still continue)[\[91\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,g.V%281%29.out%28%27created%27%29.aggregate%28%27x%27%29.in%28%27created%27%29.out%28%27created). A later cap('x') would yield the List of names. You can also specify aggregate(local, 'x') to aggregate per incoming object (less common). **Pitfall:** Because global aggregate is a barrier, it can consume a lot of memory if the traversal stream is large (it waits to collect everything). If you don’t need to preserve order and just want a set, consider groupCount or using dedup after aggregation. Also, remember that after aggregate('x'), each object still goes onward; if you don’t want them to continue, you might end the traversal or use cap. |
| store('key') | Side Effect (sideEffect) | _(deprecated)_ | Object → Object | _Use aggregate_ | In older Gremlin, store did a similar collection but without barrier semantics. In 3.x, use aggregate which unifies the behaviors. |
| group() | Barrier (map) | –   | Object → Map | g.V().group().by('country').by(count()) | Aggregates traversers into a Map. This step is a **barrier** that waits for all input before emitting the final map[\[51\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Cap%20Step). The first by specifies how to group (e.g. by a vertex’s country property), the second by specifies how to aggregate group values (here count them). Without any by() modulators, it groups by the object itself and collects values into a list. If used mid-traversal and you want to keep going, you likely intended group('key') with a later cap('key'). Using group() by itself typically ends that branch of the traversal by producing a map. **Pitfall:** If you accidentally use group() where you meant to continue the traversal, you’ll have a Map object in the stream which may cause errors in subsequent steps (they expect elements, not a map). In such cases, either use group('key') and cap to continue, or immediately unfold() the map if you need to process entries. |
| group('key') | Side Effect (sideEffect) | –   | Object → Object (same) | g.V().group('m').by(label).by(values('age').mean()) | Same aggregation as group(), but stores the resulting map in a side-effect variable 'm' instead of emitting it[\[51\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Cap%20Step). The original traversers pass through unchanged (after contributing to the group calculation). Typically followed by a cap('m') at the end to retrieve the map[\[92\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=console%20). **Pitfall:** If you forget to do cap('m'), your traversal might not output what you expect – it will output the original objects (since group as side-effect doesn’t replace them). If you use multiple group side-effects (with different keys), remember to cap each if needed (or use cap('a','b') to get both at once). |
| groupCount() | Barrier (map) / Side Effect | –   | Object → Map or Object | g.V().groupCount().by('name') | Without parameters, as a **barrier**: returns a Map of objects to counts (like a frequency table). In the example, it outputs a map of names to how many times each occurs. As a side-effect (groupCount('key')), it will increment counts in a side-effect map and pass the object through. This is a specialized case of group for counting frequencies. **Pitfall:** If used as groupCount() mid-traversal, the output is a map – further steps must handle that map. Usually you’d terminate or cap it. |
| count() | Barrier (map) | –   | Object → Long (number) | g.V().has('status','active').count() | Counts the number of traversers (or items in a group if used with scope local). When used at the end of a traversal, it gives the total count of results. When used mid-traversal (especially with scope(local) in certain contexts like after a branch or within select), it yields the count for that grouping. **Pitfall:** A common confusion is counting vs filtering by count. E.g., g.V().out().count().is(0) does not mean “vertices with no outgoing edges” – that traversal will return 0 or some number (the count of all outgoing edges from all vertices). To filter vertices with no outgoing edges, you’d do g.V().not(out()). If you need to use count in a conditional, often you want it inside a where() or choose(). |
| sum() / min() / max() / mean() | Barrier (map) | –   | Object (numeric) → Number | g.V().values('age').mean() | These compute aggregate statistics on numeric traversers. E.g., sum of all, min, max, average. Non-numeric inputs will likely error or be ignored. **Pitfall:** If there are no input traversers, min, max, and mean might return null or no result (mean of empty set undefined), and sum returns 0 (as an identity)[\[93\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,that%20userA%20hasn%27t%20already%20liked). Check for empty-case if needed. |
| fold() | Barrier (map) | –   | Object → List | g.V().values('name').fold() | Aggregates all inputs into a List (as a single traverser)[\[53\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,%2F%2F%2F%2F%20%284)[\[94\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1.%20A%20parameterless%20,and%20then%20emit%20the%20list). If no inputs, yields an empty list. Often used to collect results for further computation in-place (sometimes paired with unfold() later). **Pitfall:** As with any barrier, fold() waits for all traversers. If used on an infinite or very large stream without caution, it can exhaust memory. If folding large result sets, consider using a streaming approach or an OLAP job. |
| unfold() | FlatMap | –   | Iterable or Map → Element | g.V().values('name').fold().unfold() | The opposite of fold: takes something iterable (a list, iterator, map, etc.) and emits each element as a traverser[\[89\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20aggregate%20step). If the input is a Map, it emits map _entries_ (as Map.Entry objects in Java, but GLVs might convert to two-element tuples or keep as a map per entry). For a list, it emits each item. If used on a non-collection object, it will treat it as a single-element collection (thus unfold() on a single element just returns that element). **Pitfall:** If you unfold() a Map and then want to treat keys/values, you may need additional steps (like mapKeys, not present, so typically one would do something like unfold().select(key), but here unfold’s output isn’t labeled, it’s just entry objects which GLV might not expose cleanly – often easier to use project or select on known structures than to unfold raw maps). |
| cap(sideEffectKey...) | Side Effect (barrier) | –   | ∅ → Value(s) | g.V().group('m').by(label).by(count()).cap('m') | **Captures** the side-effect value by key, emitting it downstream[\[51\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Cap%20Step)[\[95\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%2F%2F2). In the example, after grouping is done, cap('m') outputs the aggregated map. If multiple keys are provided (e.g., cap('a','b')), the output is a map of key to value for those side-effects[\[96\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=g). **Pitfall:** cap is a barrier – it triggers the traversal to compute the side-effects up to that point. Also, a cap must refer to a side-effect that was created earlier in the traversal (like by aggregate('x'), group('m'), etc.). If the side-effect was not initialized because the step creating it was never executed (e.g., inside an optional branch not taken), cap will return nothing or throw an error. Make sure the logic guarantees the side-effect exists when reaching cap. |
| subgraph('key') | Side Effect (sideEffect) | –   | Element → Element (same) | g.V(start).repeat(\__.out().simplePath()).times(2).subgraph('sg').cap('sg') | Gathers vertices and edges seen so far (up to this step) into a subgraph side-effect (key 'sg')[\[49\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20aggregate%20step). By default, it captures the elements _at this point_ of the traversal path (not necessarily the entire neighborhood of those elements, only what traversers have touched). After the traversal (with cap), it yields a Subgraph object (which in GLV might be realized as a graph or some structure of elements). **Pitfall:** The subgraph is built as traversers pass; using it in a loop might accumulate partial paths. Ensure you place subgraph('x') at the correct step to capture what you need. Also, the subgraph is disconnected from the original graph – updates to original graph after won't reflect. In OLAP, subgraph may not be supported (some graph computers disallow mid-traversal graph capture). |
| sack() | Side Effect (map) | –   | Object → SackValue | g.withSack(0).V().has('name','marko').repeat(\__.out().sack(sum).by('weight')).times(2).sack() | Retrieves the current sack value (per traverser). In the example, we initialized each traverser’s sack to 0 and during a repeat, we add edge weights to the sack (via sack(sum).by('weight') on each out-edge). After 2 hops, calling sack() outputs the accumulated weight. **Pitfall:** Sacks must be set up via withSack(initialValue) on the traversal source; if you use sack() without initialization, it’s null. Also, sack uses in-memory accumulation – be mindful of memory if sacks hold large data. Sacks are primarily useful in OLAP or complex computations; for simple needs, other side-effects can suffice. |
| profile() | Side Effect (barrier) | –   | Object(s) → ProfileResult | g.V().has('name','Marko').out().profile() | Runs the traversal and produces a profile report of metrics (timings, counts)[\[97\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=call,415). The output is a traversal Metrics object (in GLV it may be a map or custom object with metrics). It consumes and drains the traversal (similar to a fold) to gather stats, then yields the result data structure. **Pitfall:** Using profile() will **consume** the traversal – it doesn’t yield the original data. If you want both data and profile, use side-effect or iterate twice. It’s typically terminal: e.g., in Gremlin Console, profile() prints a report. In GLVs, you get a metrics object you must interpret. |
| explain() | Side Effect (barrier) | –   | Object(s) → Explanation | g.V().out('knows').explain() | Similar to profile() but does not actually run the traversal – it returns a static explanation of the traversal’s planned execution (showing applied optimizations, etc.). The output is a textual or structured explanation (depending on GLV). **Pitfall:** As a development tool, not used in production traversals. Also, calling it in GLV will likely yield an explanation string or object that you need to print to read. Like profile, it’s terminal (consumes the traversal in the process of producing the explanation). |

### Data Retrieval and Projection Steps

These steps extract or transform the data carried by traversers – e.g. retrieving element properties, projecting to maps or tuples, or constructing path/result structures.

| Step | Category (Type) | Aliases / Variations | Input → Output | Example (Gremlin-JS) | Notes / Common Pitfalls |
| --- | --- | --- | --- | --- | --- |
| values(propKey...) | Value Extraction (map) | –   | Element → Property Value(s) | g.V().hasLabel('person').values('name','age') | Extracts the values of the given property key(s) from an element[\[98\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60values%28%29%60,in%20the%20traversal%20stream). If multiple keys are provided, it emits one traverser per key. For example, the query outputs all person names and ages as separate results (not as a tuple). If a vertex has no such property, nothing is emitted for that key (filtering that traverser out for that key). **Pitfall:** If you want to retrieve a **list** or map of values per element, use valueMap. values() by itself will flatten all requested values from all elements into one stream, losing association of which value came from which element. |
| properties(propKey...) | Property Extraction (flatMap) | –   | Element → Property (object) | g.V(1).properties('name') | Retrieves the actual **Property** objects for the given keys on the element[\[99\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%3D%3D,0). For vertices, these are VertexProperty instances (which themselves can have meta-properties); for edges, Property instances. This allows you to access metadata of the property (like id, label (key), or iterate meta-properties on a VertexProperty). Usually followed by .value() or .key() to extract the actual data. If no key is given, returns all properties. **Pitfall:** Iterating properties can be expensive if an element has many properties. If you only need the value, values() is simpler. Also, note that element.properties() in structure API is different from this traversal step – prefer traversal form in Gremlin as it’s lazy and consistent across providers[\[100\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=PropertyMap%20Step). |
| elementMap(keys...) | Value Projection (map) | –   | Element → Map<_,_\> | g.V(2).elementMap('name','age') | Similar to valueMap, but includes the element’s id and label by default, and structures data slightly differently (especially for edges, it will include the ids of both inV and outV in the map). For example, elementMap('name') on a vertex yields a map like {id: 2, label: 'person', name: 'vadas'} (single value instead of list when property is singular). **Pitfall:** If an element has multi-properties, elementMap might pick one or still list them – be mindful that it may flatten some data which could be lossy. Also, elementMap can’t include meta-properties of a VertexProperty; use valueMap(true) for full detail in that case. |
| propertyMap(keys...) | Value Projection (map) | –   | Element → Map&lt;String,Property&gt; | g.V(2).propertyMap('name','age') | Returns a map of property _objects_ (not values) for the specified keys. Essentially, it’s like valueMap but the values in the map are the full Property (or VertexProperty) instances. This allows access to property ids or meta-properties. Not commonly used unless working with meta-properties. For example, on a vertex with a multi-valued property, propertyMap('tag') might yield {tag=\[vp\[tag->val1\], vp\[tag->val2\]\]} where each is a VertexProperty object. **Pitfall:** Many GLVs might not have a direct method for propertyMap (it could be called via properties().group() in older approaches). If using Gremlin-JS and it lacks propertyMap, an alternative is to do properties(...).as('p').group().by(key).by(\__.select('p')) which is cumbersome. Check your GLV docs. |
| key() | Property Meta (map) | –   | Property → String | g.V().properties('name').key() | For a Property (e.g., from properties() step), yields the property’s key[\[103\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60key%28%29%60,extracts%20the%20key%20from%20it). E.g., might output "name" for each property object. If used on a Vertex or Edge (which isn’t a property), it’s not applicable (will likely throw an error). |
| value() | Property Meta (map) | –   | Property → Value | g.V().properties('name').value() | For a Property object, returns the value of that property[\[103\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60key%28%29%60,extracts%20the%20key%20from%20it). Essentially the inverse of properties()->value(). If used on an Element directly, it’s not valid (only for Property traversers). |
| element() | Property Meta (map) | –   | Property → Element | g.V().properties('name').as('p').element().as('v').select('p','v') | Moves from a property to the element that owns it[\[104\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20,that%20owns%20it) (vertex, edge, or vertex property). This is helpful if you traversed to some property (perhaps a meta-property on a vertex property) and need to get back to its parent element without tracking it via labels. **Pitfall:** Only works when the traverser is at a Property (or VertexProperty). If you call it on a vertex, you might erroneously think it gives connected element, but that’s not its role (for edges/vertices, use navigation steps instead). |
| map(function/traversal) | Transformation (map) | –   | Object → Object (any) | g.V().map(\__.outE().count()) | Applies an arbitrary function or traversal to the current object, yielding the result. It’s like a one-object transform (1 → 1). In this example, each vertex is mapped to the number of outgoing edges it has (via a traversal that counts outgoing edges)[\[105\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=console%20)[\[106\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,2). If the function returns no value (or traversal yields nothing), map will emit a null (which may be dropped by subsequent steps like filter if not handled). **Pitfall:** If the mapping traversal returns multiple objects for a single input, use flatMap instead (or accept that you get an iterator object as the single output, which is usually not what you want). Also, heavy use of lambdas (map{}) can reduce portability and prevent query optimization[\[107\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Tip) – prefer traversal-based mapping when possible (as shown with \__.outE().count()). |
| flatMap(traversal) | Transformation (flatMap) | –   | Object → 0..\* Objects | g.V().flatMap(\__.bothE().values('weight')) | Applies a traversal to the current object and flattens all results into the output stream[\[108\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=FlatMap%20Step). For example, one vertex might produce many edge weights, all of which become individual outputs. If the traversal yields nothing, that input produces no output (effectively filtered). **Pitfall:** Similar to map, but if your function always returns exactly one result per input, using flatMap will still work (it just yields one). The main pitfall is if you accidentally use map where you needed flatMap – you’d get an iterator or list object rather than its contents. Conversely, using flatMap when only one result per input might be slightly less efficient but not logically wrong. |
| math(expression) | Numeric (map) | –   | Number (or Map) → Number | g.V().values('x','y').as('x','y').math('x + y') | Evaluates a mathematical expression using either the current object (if a Number) or bindings[\[109\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#traversal#:~:text=,Min%20Step). In the example, we label two values and then math('x + y') will add them. It can parse basic arithmetic and uses any variables that have been labeled or are current (like using _ for the current numeric value). **Pitfall:** This step is powerful but somewhat limited to arithmetic and a set of functions. If variables are missing (not in scope), it errors. If you use it on a Map (e.g., output of select() with multiple labels), you refer to keys by name in the expression. E.g., after a select('x','y'), use math('x + y'). Ensure those keys exist in every input, otherwise math will throw. |
| select(label…) | Projection (map) | –   | Object (with path) → Object or Map | g.V().as('a').out('knows').as('b').select('a','b') | Projects one or more previously labeled objects from the traverser’s path[\[33\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,a%3Apeter%2Cc%3Amarko). With a single label, it returns that object directly; with multiple labels, it returns a Map of label->object. The example yields each pair of "a" and "b" (person and their known friend) by name if followed by .by('name'). **Common pitfall:** If you use select('a') after labeling multiple objects, you get just the last occurrence of 'a' in the path (if 'a' was reused in loops), but if you intended to get a list of all 'a' in path, you need select(all, 'a') using scope (which Gremlin-JS may not support easily). Also, if a label doesn’t exist in the traverser’s path, select will throw an error. If you want to safely select optional labels, you can do select('a').fold() to get an empty list when missing instead of error, for example. |
| project(label1, label2, ...) | Projection (map) | –   | Object → Map | g.V(1).project('name','outCount').by('name').by(outE().count()) | Allows arbitrary projection of the current object into a Map with specified keys. Each key gets a traversal via a by() modulator. The example outputs for vertex 1: {"name": "marko", "outCount": 3} (assuming Marko has 3 outgoing edges). This is very useful for shaping custom result structures without needing to use as()/select(). **Pitfall:** Every by() must be provided or it defaults to identity (the object itself) for that field if missing. If you do project('a','b').by(...).by(...) and your traversals produce different numbers of results, project does not inherently align them – but since it’s one input at a time, each by is evaluated on the same input object, so typically each yields one result. If a by yields multiple, Gremlin will wrap them in a list for that entry. If a by yields nothing, that entry might be absent or null (which can be confusing). Also, project outputs a Map per input – if you project at the end of a traversal of many elements, you get many maps (which is usually fine). |
| order() | Order (by comparator) | –   | Object... → Object... (sorted) | g.V().hasLabel('person').order().by('age', incr) | Sorts the traversers in the stream. By default, it sorts in natural order of the objects, but it usually requires a .by() modulator to specify a sort key or traversal, and an optional order (ascending incr or descending decr)[\[110\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=TinkerPop%20does%20not%20guarantee%20the,step). The example sorts person vertices by their age property ascending. If multiple by() are provided, they act as tie-breaker secondary sorts. **Pitfall:** Sorting is a blocking (barrier) operation – it waits to receive all traversers, then sorts, then emits them. On large graphs this can be heavy on memory. Also, sorting elements without specifying a criterion may not make sense (vertices don’t have a natural ordering unless IDs are comparable). It’s recommended to always use by(property) or by(some traversal) so you know what you’re sorting on. Another common mistake is expecting order to be stable across multiple runs – if the data or iteration order changes, results can come out differently unless sorted by a deterministic key. |
| limit(n) / tail(n) / skip(n) / range(s,e) | (See Filtering: result limiting) | –   | Object → Object (subset) | g.V().order().by('name').limit(10) | (These were covered under **Filtering Steps** above, as they filter by index/range. In use, they often come after an order() step to paginate results.) |
| path() | Path (map) | –   | Object → Path (list) | g.V(1).out('knows').out('created').path() | Constructs a Path object for each traverser, representing the sequence of objects (and labels) it went through[\[111\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20traversal%20mechanics). The example would yield paths like \[v\[1\], v\[2\], v\[3\]\] for Marko → Vadas → what Vadas created (assuming v\[3\] is Lop), etc. Each entry in the path retains its type (Vertex, Edge, property, or value) unless you use a by() modulator to project path components. **Pitfall:** Path objects can consume a lot of memory if your traversal touches many objects or loops a lot[\[112\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Warning). TinkerPop will avoid keeping full paths unless a step like path() or a match() requires it[\[113\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Path%20calculation%20is%20costly%20in,path%20calculations%20are%20turned%20off). Also, when using path(), often you’ll want to format it (e.g., .by('name') to only show names instead of full Vertex objects in the path). If you see raw references like v\[1\] in output, that’s the default element toString(). Use by() to make the path human-readable (but note that then the path entries are whatever you projected, not the raw elements). |
| tree() | Path/Structure (sideEffect) | –   | Object → Tree | g.V(1).out().out().tree() | Collects traversers into a tree data structure[\[114\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60aggregate%28%29%60,to). The output is a Tree (which is essentially a nested map from object to its children). In the example, it would produce a tree with root 1 (Marko) having branches to the vertices Marko.out(), and those each having branches of their out(). It’s usually used without further traversal after, as a terminal step. **Pitfall:** As a side-effect, tree('t') can be used to build the tree while continuing traversal, but merging trees can be tricky if multiple traversers share branches. Typically, use tree() at the end. The Tree output might not be easily serializable to JSON directly (GLVs might convert it to a map-of-maps). Large trees (deep or broad) can also consume significant memory. |
| match() | (see Branch/Loop) | –   | –   | –   | _(See_ _Branching & Looping_ _for match usage; it produces projections similar to doing multiple selects.)_ |
| select() / project() | (see above) | –   | –   | –   | _(Covered above in this section.)_ |

## 3\. Usage Patterns and Examples

Most Gremlin traversals in real-world use combine a handful of these steps to express a query or graph update. For example, a typical pattern might be: start at some vertices, apply a few navigation steps, filter by properties, maybe branch or repeat for a certain depth, then project the results. Here we highlight a few common patterns and idioms using the steps:

- **Basic traversal query:** To get the names of Marko’s friends and the projects they created, one could write:

g.V().has('person','name','marko').out('knows').as('friend')  
.out('created').as('project')  
.select('friend','project').by('name')

This uses has (filter start to Marko), out (navigate to friends), then another out (to projects), and finally select to project the friend and project names. It demonstrates **labeling** with as and later retrieval with select. Such a traversal is foundational – using _navigation_ and _filtering_ (the has step) along with a simple projection.

- **Conditional traversal:** If we want to traverse “knows” edges if the person is under 30, otherwise “created” edges (similar to an if/else), we could use choose:

g.V().hasLabel('person').choose(  
\__.values('age').is(P.lt(30)),  
\__.out('knows'),  
\__.out('created')  
)  
.values('name')

This uses a **branch** step to decide which direction to go for each person. We see the anonymous traversal \__.values('age').is(P.lt(30)) as the condition, and two traversal options. The result is a mix of names that were either known-by or created-by those people, depending on age. The example shows how **branch steps** incorporate sub-traversals (and how Gremlin-JS uses the \__ static to start an anonymous traversal).

- **Aggregation and sideEffect:** To collect all people that a given person knows into a list (and maybe then filter by something), one might do:

g.V(personId).out('knows').aggregate('friends').  
// side effect: collect friends  
// (perhaps more traversal here)  
cap('friends')

The aggregate('friends') step stores each friend in a list under the key 'friends'[\[89\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20aggregate%20step). The traversal then uses cap('friends') to output the accumulated list[\[51\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Cap%20Step)[\[96\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=g). This pattern shows how to maintain state and then retrieve it. A common **pitfall** with this pattern is forgetting cap – without it, the traversal above would output the original friends as individual traversers (because aggregate doesn’t remove them), whereas with cap we get one list. If we wanted to continue traversing after capturing, we might store in a side-effect and not cap until the end.

- **Repeat (looping):** A traversal to get all people within 2 hops in a social network could use repeat:

g.V(startId).repeat(\__.out('knows')).times(2).emit().values('name')

This starts at the person, then repeats going out “knows” twice. The emit() with no condition ensures that it emits intermediate results as well (so it will emit those at distance 1 and distance 2)[\[29\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=console%20). If we only wanted exactly 2 hops, we could omit emit() and just get the distance-2 people. **Pitfall:** Without emit, you would only get the result at the end of 2 hops (distance-2). With emit(), you get distance-1 and distance-2. If we used until instead of times, say until some condition on the vertex, we should be careful to also possibly use emit if we want to include the vertex where the condition became true.

- **Using match:** An example using match for a more complex pattern: find two people who worked on the same project:

g.V().hasLabel('person').as('a').  
match(  
\__.as('a').out('created').as('p'),  
\__.as('b').out('created').as('p')  
).  
select('a','b').by('name')

Here match finds a pattern where person 'a' and some other person 'b' (implicitly defined by appearing in second pattern) share a project 'p'. We didn’t explicitly constrain 'b' to be different from 'a' – we could add another pattern \__.as('a').neq('b') or use where(neq('a')) on 'b'. This shows how match can relate multiple variables in one go. It outputs pairs of names. However, match is often considered advanced; the same query can be done with nested traversals or repeat/dedup too. The benefit of match is clarity when patterns are complex and letting the engine optimize join order[\[36\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=sorting%20the%20patterns%20according%20to,path%20traversals).

**Gremlin-JS Considerations:** Gremlin’s JavaScript implementation follows the same method names, but keep in mind reserved words and slightly different syntax: - Use in_() instead of in(), and with_() instead of with() (for with(WithOptions...) modulators)[\[115\]](https://stackoverflow.com/questions/66947269/in-not-available-in-javascript-gremlin#:~:text=database%20,Try%20using%20in_%28%29%20instead)[\[116\]](https://groups.google.com/g/gremlin-users/c/gYfGLrid378#:~:text=Cannot%20use%20,recently%20published%20documentation%3A%20https). Similarly, from_() if using a string in from(), though in practice one often passes a step label (which is a string) – the GLV may handle it, but the documentation indicates using the underscored version for reserved words[\[42\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Javascript). - The P predicates (like P.gt(30), P.lte(30)) are available via import (e.g., const { P } = gremlin.process;). In our examples we assumed that context. - Anonymous traversals \__ are available (e.g., \__.out()), as used in examples. - Some steps or modulators like by() may need explicit import of enums or functions for order: e.g., use order.incr or order.decr for ascending/descending, or import col for Column if needed, etc. In the above examples, we used incr as a placeholder assuming such an enum is accessible (in TinkerPop JS, order.asc might be the actual usage).

Many common Gremlin patterns (like “get neighbors of neighbors”, “if absent then create”, “gather and filter later”) emerge through combining these steps. By understanding each step’s semantics from the reference above, you can compose them for virtually any graph query or mutation.

## 4\. Meta-Analysis of the Gremlin Step Library

**Learning progression:** Gremlin’s step library can be overwhelming, but not all steps are equally important to master initially. A small subset of steps covers the majority of practical use cases (the Pareto principle ~80/20). At the **Foundational** level, developers should first become fluent with the basics: the **graph navigation steps** (V/E start, out/in/both and their edge variants)[\[3\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20vertex%20steps%20,traverse), basic **property filters** like has and where, and simple **projections** (values, select). These steps (plus count and maybe order) likely account for a large portion of real-world traversals. Indeed, queries that “find vertices by property, follow edges, maybe filter further, and retrieve some values” are extremely common. The Apache TinkerPop authors note that “the vertex steps... are fundamental to the Gremlin language”[\[3\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20vertex%20steps%20,traverse) – without mastering those, one can’t effectively traverse a graph.

At the **Intermediate** tier, one learns to combine steps for more complex logic: **branching steps** like choose and coalesce for conditional paths, **aggregation steps** like group, aggregate, and dedup for analytical queries, and perhaps **repeat** for controlled loops. Intermediate users also start using **modulators** such as by() (for ordering or grouping) and as()/select (for referencing earlier steps). A common subtlety here is understanding **scoping** – e.g. the difference between local and global scopes in certain steps, or how select('x') picks up the last occurrence of label 'x' in the traversal path. An example pitfall: misuse of the local scope – the TinkerPop docs mention that _using local() can often be a mistake when a reducing step is inside it_, as it might produce confusing results by resetting aggregation per object[\[117\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Use%20of%20,in)[\[118\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1,rather%20than%20each%20global%20traverser). This is something an intermediate user learns (e.g., prefer map() over local() in many count/sum cases[\[119\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=because%20the%20counting%20is%20happening,rather%20than%20each%20global%20traverser)).

At an **Advanced** level, a user is comfortable with nearly all core steps, including complex ones like match (for pattern matching) and union/optional (for complex conditional flows). They also manage intricacies such as **path-centric filters** (simplePath, cyclicPath) and **side-effect carriers** like sack. They understand how to use profile() to optimize queries and how Gremlin strategies might rewrite their traversals. Advanced users also navigate the differences between OLTP and OLAP traversals – for example, knowing that steps like pageRank() or connectedComponent() require a graph computer and won’t run in standard OLTP mode[\[61\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L6632%20The%20%60pageRank%28%29%60,%28OLAP). They also start recognizing when a custom traversal strategy or even a custom step might be needed for performance.

At the **Expert** tier, one deals with graph computer algorithms and vendor-specific optimizations. They might use program() to inject custom OLAP computations[\[62\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60program%28%29%60,configuration%20provided%20to%20the%20vertex), or call() to invoke specialized indexed queries on certain graph systems. They are also wary of transactional nuances and idiosyncrasies of different graph providers (e.g., how certain steps might not be supported or might behave slightly differently, which TinkerPop tries to minimize). Experts also contribute new DSLs or extend Gremlin.

**Fundamental vs. Rare steps:** In practice, the **most fundamental steps** are those for graph navigation and simple filtering: out()/in(), has(), filter(), not(), and()/or(), plus projection like values() and basic reducing like count() and order(). These likely constitute ~80% of Gremlin usage in common queries. A typical user’s first dozen Gremlin queries rarely go beyond these. TinkerPop’s reference documentation and community examples heavily feature them[\[120\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Given%20the%20TinkerPop%20graph%2C%20the,Groovy)[\[121\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%3D%3D,josh). As an example, if one inspects open-source Gremlin query repositories or the Apache TinkerPop test suite, queries mostly string together these fundamental steps.

On the other hand, there are steps which are **rarely used or easily confused**: - Steps like index() (which indexes list entries) or store() (deprecated) are seldom seen in day-to-day queries. They solve niche problems (e.g., numbering list items) and many users might not encounter them. - The call() step is intentionally low-level and vendor-specific – it’s essentially a hook for non-Gremlin operations[\[122\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20,custom%20analytics%2C%20notification%20triggers%2C%20etc), so it’s not used unless you need to access a graph system’s special feature. Most users can ignore call() entirely. - OLAP algorithm steps (pageRank, etc.) are specialized – if you’re doing graph analytics, you might use them, but typical OLTP query patterns (e.g., in a web app) won’t. - fail() is more of a debugging/guard step; it’s not part of most functional traversals except to enforce a precondition. - The entire IO series (io(), read(), write()) is for data import/export. They’re not used _within_ a typical query, but rather as top-level commands in scripts for bulk loading or saving. Many users never use io() from Gremlin, as data loading might be done via other means. - Some modulators like withStrategies or withoutStrategies are expert-level toggles to alter the traversal behavior (turn off an optimization, etc.) – extremely rare in normal usage.

**Common pitfalls and subtle semantics:** A few are worth re-emphasizing: - **Incorrect assumption of traversal state:** For example, using a step after a barrier without realizing the type changed. A user might do g.V().group().by(label).by(count()).out() thinking to traverse further from the grouped result – but after group() the traverser is a Map, and out() can’t be applied (leading to a runtime error about “Vertex step on non-vertex”). The fix is usually to restructure the traversal or use cap and then start a new traversal on the map’s contents if needed. - **Label and scope misuse:** As mentioned, doing has('name', select('n')) is a logical error[\[77\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=effectively%20,has) – the user perhaps wanted to filter by a previously selected name, but select('n') yields an object making has always true (because the traversal exists) rather than comparing values. The correct approach would be where(P.eq('n')) or where(\__.select('n')) in that context[\[77\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=effectively%20,has). This confusion between using select inside has or where trips up many beginners. - **Local vs global in where:** where(someCriterion) by default checks the _current object_ (like a filter), whereas where(...as('x')...) or where(eq('x')) goes global in path. It’s subtle that where(\__.out()) is different from where(out()) in Groovy (the former is global, the latter shorthand might be local or cause a subtlety – generally one uses the anonymous traversal form to be clear). New users sometimes expect where() to do things it doesn’t, like filter by a property value directly (which is actually what has is for). - **Using match vs simpler traversals:** Sometimes users reach for match when a simpler and() or nested traversal would do, potentially complicating the query. Conversely, not using match when it’s appropriate (for complex multi-hop queries) can lead to overly complicated traversals. There’s a learning curve to know when match is beneficial. The documentation notes that match() finds an optimal plan for unknown stats and can be easier for certain queries[\[36\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=sorting%20the%20patterns%20according%20to,path%20traversals). - **Ordering and range:** Assuming a traversal’s output is in some meaningful order without an explicit order() step is a pitfall. TinkerPop explicitly warns that result ordering is not guaranteed unless explicitly sorted[\[110\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=TinkerPop%20does%20not%20guarantee%20the,step). For example, g.V().limit(5) might not give the “first 5 by id” – it will give five arbitrary vertices based on how the graph iterates. You must do order().by(id).limit(5) if you expect the lowest 5 IDs. Many novices don’t realize this nondeterminism. - **Repeat loops not terminating:** It’s easy to create an infinite loop if the exit condition is wrong or if the graph has cycles and you forgot a simplePath() filter. A common best practice is to include simplePath() or check loops() count to ensure termination. We saw in our taxonomy that repeat() should always be used with care to include .until or .times – forgetting that is a classic bug. - **Bulk vs. single traversers:** Some steps (like dedup, range, etc.) operate on traverser bulk as well. If using inject or other ways to add traversers with bulk, one must recall how dedup will reduce bulk to 1 for duplicates[\[80\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L3583%20With%20%60dedup%28%29%60,to%201%20before%20being%20emitted). This is advanced, but can surface if someone uses count().is(gt(5)) vs where(count(local).is(gt(5))) – the difference between counting traversers globally vs locally can trip people up. - **Graph provider idiosyncrasies:** Not a Gremlin step issue per se, but an edge: some graph databases might not support certain steps (or they are not enabled). For example, older Cosmos DB Gremlin didn’t support addV() mid-traversal (only at start), or some might not support sack() or certain algorithms. While this isn’t a “Gremlin semantics” issue, a user might be confused why a traversal fails on one graph but not another. The remedy is usually to consult provider docs and ensure only core steps are used, which is exactly why sticking to the core (as we have here) is important for portability.

In summary, mastering Gremlin steps involves understanding their fundamental behaviors (map, flatMap, filter, sideEffect, branch)[\[1\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1.%20,S%20%E2%86%92%20E), building up from simple patterns to complex ones, and learning by experience where pitfalls lie. The core steps and patterns described above form a toolkit that can express very sophisticated graph queries. With practice, a developer learns to “think in Gremlin” – breaking down a problem into sequences of these step operations (often in multiple ways, since Gremlin is very flexible). Keeping this reference at hand and referring to the official documentation[\[123\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20library%20of%20Gremlin%20steps,for%20that%20sort%20of%20information)[\[120\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Given%20the%20TinkerPop%20graph%2C%20the,Groovy) when unsure can help avoid common errors and fully leverage the power of the TinkerPop Gremlin traversal machine.

**Sources:**

1. Apache TinkerPop 3.6.3 Reference Documentation – Gremlin Steps and Traversal Concepts[\[1\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1.%20,S%20%E2%86%92%20E)[\[3\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20vertex%20steps%20,traverse)[\[118\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1,rather%20than%20each%20global%20traverser)[\[60\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60pageRank%28%29%60,using%20PageRankVertexProgram)
2. Apache TinkerPop 3.6.3 Reference Documentation – Step Reference (Filter, Branch, SideEffect, etc.)[\[19\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60drop%28%29%60,traversal%20yields%20no%20outgoing%20objects)[\[20\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Choose%20Step)[\[27\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60optional%28%29%60,identity)[\[124\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20,Steps%20section%20for%20more%20information)
3. Apache TinkerPop 3.6.3 Reference Documentation – Examples and Explanations (choose, aggregate, local vs map)[\[87\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20choose%20step)[\[89\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20aggregate%20step)[\[117\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Use%20of%20,in)
4. _Practical Gremlin_ by Kelvin Lawrence – (for general Gremlin patterns and best practices, though not directly cited above).

[\[1\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1.%20,S%20%E2%86%92%20E) [\[2\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=5.%20,%7D%20%E2%86%92%20E) [\[3\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20vertex%20steps%20,traverse) [\[4\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,vertices%20given%20the%20edge%20labels) [\[5\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,vertices%20given%20the%20edge%20labels) [\[6\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,edges%20given%20the%20edge%20labels) [\[7\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,outgoing%20vertex) [\[8\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,vertices) [\[9\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20inject%20step) [\[10\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=console%20) [\[11\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%60filter%28Traversal) [\[12\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L2312%203,with%20respective%20predicate) [\[13\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L3044%20,modulation) [\[14\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L3525%20%60cyclic%28%29%60,behavior%20is%20desired%2C%20see%20simplePath) [\[15\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Where%20Step) [\[16\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,peter) [\[17\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L2744%20The%20%60and%28%29%60,semantics) [\[18\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=To%20randomly%20filter%20out%20a,coin%20toss) [\[19\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60drop%28%29%60,traversal%20yields%20no%20outgoing%20objects) [\[20\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Choose%20Step) [\[21\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1,based%20option%20selection) [\[22\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%28i.e.%20value) [\[23\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1,created%2C%20else%20emit%20the%20vertex) [\[24\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=g,values%28%27name%27%29%20%2F%2F2) [\[25\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Coalesce%20Step) [\[26\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L3328%20gremlin,vadas) [\[27\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60optional%28%29%60,identity) [\[28\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Another%20example%20is%20the%20repeat%28%29,a%20loop) [\[29\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=console%20) [\[30\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin%3E%20g.V%28%29.emit%28__.has%28,lop) [\[31\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Loops%20Step) [\[32\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60match%28%29%60,provided%20is%20called) [\[33\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,a%3Apeter%2Cc%3Amarko) [\[34\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,a%3Apeter%2Cc%3Amarko) [\[35\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=traverser%20%28i,Furthermore%2C%20some%20queries%20are) [\[36\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=sorting%20the%20patterns%20according%20to,path%20traversals) [\[37\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=AddV%20Step) [\[38\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%3D%3D,v%5B15) [\[39\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60addV%28%29%60,method) [\[40\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=3,edge%20for%20all%20created%20edges) [\[41\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=5,that%20supports%20user%20provided%20ids) [\[42\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Javascript) [\[48\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=3.%20,S%20%E2%86%92%20E%20%E2%8A%86%20S) [\[49\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20aggregate%20step) [\[50\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Aggregate%20Step) [\[51\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Cap%20Step) [\[52\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=There%20are%20situations%20when%20the,step%20for%20the%20inverse%20functionality) [\[53\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,%2F%2F%2F%2F%20%284) [\[54\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,a%20%2B%20b.length) [\[55\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%3D%3D,g.V%28%29.values%28%27age%27%29.sum%28%29%20%2F%2F%2F%2F%20%286) [\[56\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin%3E%20g.V%28%29.values%28%27age%27%29.fold%280%29%20%7Ba%2Cb%20,2%5D%29.fold%28%5B%5D%2C%20addAll%29%20%2F%2F%2F%2F%20%287%29%20%3D%3D%3E%5B%5Ba%3A1%5D%2C%5Bb%3A2) [\[57\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L3481%20Image%3A%20count,step) [\[58\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Fail%20Step) [\[59\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,) [\[60\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60pageRank%28%29%60,using%20PageRankVertexProgram) [\[61\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L6632%20The%20%60pageRank%28%29%60,%28OLAP) [\[62\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60program%28%29%60,configuration%20provided%20to%20the%20vertex) [\[63\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,vadas) [\[64\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,vertices%20given%20the%20edge%20labels) [\[65\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=) [\[66\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=labels) [\[67\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,edges%20given%20the%20edge%20labels) [\[68\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,g.V%284%29.bothE%28%27knows%27%2C%27created%27%2C%27blah) [\[69\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,edges%20given%20the%20edge%20labels) [\[70\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,edges%20given%20the%20edge%20labels) [\[71\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin%3E%20g.V%284%29.inE%28%27knows%27%29%20%2F%2F%2F%2F%20%282%29%20%3D%3D%3Ee%5B8%5D%5B1,4%5D%20gremlin%3E%20g.V%284%29.bothE%28%27knows%27%2C%27created%27%2C%27blah%27%29.otherV%28%29%20%3D%3D%3Ev%5B5) [\[72\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,outgoing%20vertex) [\[73\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Identity%20Step) [\[74\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%3D%3D,lop) [\[75\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,by%20the%20functional%20programming%20community) [\[76\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,v%5B5) [\[77\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=effectively%20,has) [\[78\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Where%20Step) [\[79\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Warning) [\[80\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=match%20at%20L3583%20With%20%60dedup%28%29%60,to%201%20before%20being%20emitted) [\[81\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=With%20%60dedup%28%29%60,to%201%20before%20being%20emitted) [\[82\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,modulation) [\[83\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,g.V%281%29.out%28%27created%27%29.in%28%27created%27%29.where%28out%28%27created%27%29.count%28%29.is) [\[84\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,josh) [\[85\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Gremlin%20with%20) [\[86\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,by%28%27name) [\[87\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20choose%20step) [\[89\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20aggregate%20step) [\[90\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60aggregate%28%29%60,An%20example%20is%20provided%20below) [\[91\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,g.V%281%29.out%28%27created%27%29.aggregate%28%27x%27%29.in%28%27created%27%29.out%28%27created) [\[92\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=console%20) [\[93\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=,that%20userA%20hasn%27t%20already%20liked) [\[94\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1.%20A%20parameterless%20,and%20then%20emit%20the%20list) [\[95\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%2F%2F2) [\[96\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=g) [\[97\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=call,415) [\[98\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60values%28%29%60,in%20the%20traversal%20stream) [\[99\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%3D%3D,0) [\[100\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=PropertyMap%20Step) [\[101\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60valueMap%28%29%60,the%20properties%20of%20an%20element) [\[102\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60id%28%29%60,extracts%20its%20identifier%20from%20it) [\[103\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60key%28%29%60,extracts%20the%20key%20from%20it) [\[104\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20,that%20owns%20it) [\[105\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=console%20) [\[106\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=gremlin,2) [\[107\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Tip) [\[108\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=FlatMap%20Step) [\[109\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#traversal#:~:text=,Min%20Step) [\[110\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=TinkerPop%20does%20not%20guarantee%20the,step) [\[111\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Image%3A%20traversal%20mechanics) [\[112\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Warning) [\[113\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Path%20calculation%20is%20costly%20in,path%20calculations%20are%20turned%20off) [\[114\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20%60aggregate%28%29%60,to) [\[117\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Use%20of%20,in) [\[118\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=1,rather%20than%20each%20global%20traverser) [\[119\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=because%20the%20counting%20is%20happening,rather%20than%20each%20global%20traverser) [\[120\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=Given%20the%20TinkerPop%20graph%2C%20the,Groovy) [\[121\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=%3D%3D,josh) [\[122\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20,custom%20analytics%2C%20notification%20triggers%2C%20etc) [\[123\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20library%20of%20Gremlin%20steps,for%20that%20sort%20of%20information) [\[124\]](https://tinkerpop.apache.org/docs/3.6.3/reference/#:~:text=The%20,Steps%20section%20for%20more%20information) TinkerPop Documentation

<https://tinkerpop.apache.org/docs/3.6.3/reference/>

[\[43\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=One%20of%20the%20most%20compelling,your%20code%20more%20readable%20and) [\[44\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=As%20an%20example%20of%20,Vertex) [\[45\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=gremlin,code%3D%5BATL%5D%2C%20id%3D215%2C%20label%3Dairport) [\[46\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=steps%20unwind%20the%20complexity%20of,your%20code%20more%20readable%20and) [\[47\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=Note%20that%20,emergence%20of%20these%20new%20steps) [\[88\]](https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/#:~:text=gremlin,id%3D215%2C%20label%3Dairport%7D%2C%20dist%3D813) Exploring new features of Apache TinkerPop 3.6.x in Amazon Neptune | AWS Database Blog

<https://aws.amazon.com/blogs/database/exploring-new-features-of-apache-tinkerpop-3-6-x-in-amazon-neptune/>

[\[115\]](https://stackoverflow.com/questions/66947269/in-not-available-in-javascript-gremlin#:~:text=database%20,Try%20using%20in_%28%29%20instead) database - .in not available in javascript gremlin? - Stack Overflow

<https://stackoverflow.com/questions/66947269/in-not-available-in-javascript-gremlin>

[\[116\]](https://groups.google.com/g/gremlin-users/c/gYfGLrid378#:~:text=Cannot%20use%20,recently%20published%20documentation%3A%20https) Cannot use .valueMap().with(WithOptions.tokens) with gremlin ...

<https://groups.google.com/g/gremlin-users/c/gYfGLrid378>